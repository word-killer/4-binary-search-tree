# 4-binary-search-tree
Creating binary search tree

Мой вариант N=30, поэтому:
- N % 4 = 2 - для задания 2
- N % 8 = 6 - для задания 3

### 1 Задание
В задании 1 я реализовал класс бинарного дерева поиска.
Единственное поле класса это - Node* root — указатель на корень дерева.
Краткое описание реализованных в классе методов:
- Конструктор BinarySearchTree() - создаёт пустое дерево (root = nullptr)
- Деструктор ~BinarySearchTree() - рекурсивно удаляет все узлы через deleteTree(Node* node), освобождая память
- void Add(const T& value) - добавляет новый элемент в дерево, сохраняя свойства BST. Если значение меньше текущего узла — идёт в левое поддерево, иначе — в правое. Реализован итеративно (без рекурсии)
- Node* Find(const T& value) - ищет узел с заданным значением, возвращает указатель на узел или nullptr, если элемент не найден
- void Remove(Node* node) - удаляет узел из дерева. Если узел имеет двух детей — ищет минимальный элемент в правом поддереве и заменяет им удаляемый узел. Если узел имеет одного или ноль детей — корректно переназначает указатели родителей
### 2 Задание
Я реализовал поперечный (inorder) метод обхода бинарного дерева поиска, исходя из своего варианта.
```cpp
// задание 2 - метод для поперечного обхода (inorder)
void inorderTraversal(Node* node) {
        if (!node) return;
        inorderTraversal(node->Left);
        cout << node->Value << " ";
        inorderTraversal(node->Right);
    }
```
Функция выполняет симметричный (in-order) обход бинарного дерева поиска, выводя значения всех узлов в отсортированном порядке.
Принцип работы:
- рекурсивно обходит левое поддерево
- выводит значение текущего узла (cout << node->Value)
- рекурсивно обходит правое поддерево
### 3 Задание
Я реализовал кастомный метод vector<T> countNodesPerLevel(), возвращающий массив, где i-й элемент — число узлов на уровне i.
```cpp
// задание 3 - кастомный метод для подсчета узлов на каждом уровне
    vector<T> countNodesPerLevel() {
        vector<T> result;
        if (!root) return result;

        queue<Node*> q;
        q.push(root);

        while (!q.empty()) {
            int levelSize = q.size(); 
            result.push_back(levelSize);

            for (int i=0; i<levelSize; i++) {
                Node* current = q.front();
                q.pop();
                if (current->Left) q.push(current->Left);
                if (current->Right) q.push(current->Right);
            }
        }

        return result;
    }
```
Функция возвращает массив (vector<T>), где каждый элемент соответствует числу узлов на соответствующем уровне дерева. Временная сложность O(n), где n — количество узлов дерева.
Принцип работы:
- используется широкий (level-order) обход дерева с помощью очереди (queue<Node*>).
- на каждом уровне определяется количество узлов (levelSize = q.size()) и сохраняется в массив result.
- дети текущих узлов добавляются в очередь для обработки следующего уровня.
- процесс повторяется, пока очередь не станет пустой.
